//==== dev rules
//path / {
//    read() { true }
//    write() { true }
//}
//====

//===https://github.com/FirebaseExtended/bolt/blob/master/docs/guide.md
type Timestamped<T> extends T {
    modified: CurrentTimestamp,
    created: InitialTimestamp
}

type CurrentTimestamp extends Number {
    validate() { this == now }
}

type InitialTimestamp extends Number {
    validate() { initial(this, now) }
}

// Returns true if the value is intialized to init, or retains it's prior value, otherwise.
initial(value, init) { value == (prior(value) == null ? init : prior(value)) }
isCurrentUser(uid) { isSignedIn() && auth.uid == uid }
isSignedIn() { auth != null }
createOnly(value) { prior(value) == null && value != null }
postDoesNotExist(postId) { postId != null && prior(root.posts.data.posts.$postId) == null}
postDeletedAtSameTime(postId){ postId != null && root.posts.data.posts.$postId == null }
votedAtSameTimeAndNotVoted(postId,dir){
    ((root.posts.data.votes.$postId.up-prior(root.posts.data.votes.$postId.up)==1&&dir=='up')||
    (root.posts.data.votes.$postId.down-prior(root.posts.data.votes.$postId.down)==1&&dir=='down'))}
removedVoteAtSameTimeAndHasVoted(postId,dir){
    ((root.posts.data.votes.$postId.up-prior(root.posts.data.votes.$postId.up)==-1&&dir=='up')||
    (root.posts.data.votes.$postId.down-prior(root.posts.data.votes.$postId.down)==-1&&dir=='down'))}
postIdOwned(postId,userId){
    postId!=null&&root.posts.owner.$userId.posts.$postId!=null}
commentDoesNotExist(postId,commentId){prior(root.comments.posts.$postId.$commentId)==null}
commentDeletedAtSameTime(postId,commentId){root.comments.posts.$postId.$commentId==null}

commentVotedAtSameTimeAndNotVoted(postId,commentId,dir){
    ((root.comments.data.votes.$postId.$commentId.up-prior(root.posts.data.votes.$postId.$commentId.up)==1&&dir=='up')||
    (root.comments.data.votes.$postId.$commentId.down-prior(root.posts.data.votes.$postId.$commentId.down)==1&&dir=='down'))}
commentRemovedVoteAtSameTimeAndHasVoted(postId,commentId,dir){
    ((root.comments.data.votes.$postId.$commentId.up-prior(root.posts.data.votes.$postId.$commentId.up)==-1&&dir=='up')||
    (root.comments.data.votes.$postId.$commentId.down-prior(root.posts.data.votes.$postId.$commentIddown)==-1&&dir=='down'))}

commentIdOwned(postId,commentId,userId){
    postId!=null&&commentId!=null&&root.comments.owner.$userId.$postId.$commentId!=null}
//===

type TextMessageWithLocation extends TextMessage {
  location: String
}

type TextMessageContent extends String {
    validate() { this.length < 280 }
}

type TextMessage {
    type: String,
    content: TextMessageContent

    validate() { this.type == 'text' }
}

type VoteDirection extends String {
    validate() { this == 'up' || this == 'down' }
}

type Vote {
    up: Number,
    down: Number
}

path /users/{userId} {
    read() { isCurrentUser(userId) }
    write() { isCurrentUser(userId) }
}

path /sessions/{userId} {
    read() { isCurrentUser(userId) }
    write() { isCurrentUser(userId) }
}

path /presence/{userId} {
    read() { isCurrentUser(userId) }
    write() { isCurrentUser(userId) }
}

path /posts {

    path /owner {
        path /{userId} {
            read() { isCurrentUser(userId) }
            path /posts/{postId} is Boolean {
                create() { isCurrentUser(userId) && postDoesNotExist(postId) }
                delete() { isCurrentUser(userId)  && postDeletedAtSameTime(postId) }
            }

            path /votes/{postId} is VoteDirection {
                    create() { isCurrentUser(userId) && votedAtSameTimeAndNotVoted(postId,this) }
                    delete() { isCurrentUser(userId) && removedVoteAtSameTimeAndHasVoted(postId,this) }
            }
        }
    }

    path /data {
        read() { isSignedIn() }

        path /posts/{postId} is Timestamped<TextMessageWithLocation> {
            create() { isSignedIn()  && postIdOwned(postId,auth.uid)}
        }

        path /votes/{postId} is Vote {
            write() { true }
        }

    }

}


path /comments {

    path /owner {
        path /{userId} {
            read() { isCurrentUser(userId) }
            path /comments/{postId}/{commentId} is Boolean {
                create() { isCurrentUser(userId) && !postDoesNotExist(postId) && commentDoesNotExist(postId,commentId) }
                delete() { isCurrentUser(userId)  && !postDoesNotExist(postId) && commentDeletedAtSameTime(postId,commentId) }
            }

            path /votes/{postId}/{commentId} is VoteDirection {
                create() { isCurrentUser(userId) && commentVotedAtSameTimeAndNotVoted(postId,comment,this) }
                delete() { isCurrentUser(userId) && commentRemovedVoteAtSameTimeAndHasVoted(postId,comment,this) }
            }
        }
    }

    path /data {
        read() { isSignedIn() }

        path /comments/{postId}/{commentId} is Timestamped<TextMessage> {
            create() { isSignedIn()  && commentIdOwned(postId,commentId,auth.uid)}
        }

        path /votes/{postId}/{commentId} is Vote {
            write() { true }
        }

    }

}
